"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Fluent = void 0;
const dntShim = __importStar(require("../../../../_dnt.shims.js"));
const deps_js_1 = require("./deps.js");
const logging_warning_handler_js_1 = require("./warnings/logging_warning_handler.js");
class Fluent {
    constructor(options = {}) {
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: options
        });
        Object.defineProperty(this, "bundles", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (new Set())
        });
        Object.defineProperty(this, "defaultBundle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "warningHandler", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.warningHandler = options.warningHandler ||
            new logging_warning_handler_js_1.LoggingWarningHandler();
    }
    async addTranslation(options) {
        const locales = Array.isArray(options.locales)
            ? options.locales
            : [options.locales];
        const sources = await this.handleSources({
            source: options.source,
            filePath: options.filePath,
        });
        const bundle = this.createBundle({
            locales,
            sources,
            bundleOptions: options.bundleOptions,
        });
        this.bundles.add(bundle);
        // Saving reference to the default bundle
        if (!this.defaultBundle || options.isDefault) {
            this.defaultBundle = bundle;
        }
    }
    addTranslationSync(options) {
        const locales = Array.isArray(options.locales)
            ? options.locales
            : [options.locales];
        const sources = this.handleSourcesSync({
            source: options.source,
            filePath: options.filePath,
        });
        const bundle = this.createBundle({
            locales,
            sources,
            bundleOptions: options.bundleOptions,
        });
        this.bundles.add(bundle);
        // Saving reference to the default bundle
        if (!this.defaultBundle || options.isDefault) {
            this.defaultBundle = bundle;
        }
    }
    translate(localeOrLocales, path, context) {
        const locales = Array.isArray(localeOrLocales)
            ? localeOrLocales
            : [localeOrLocales];
        const bundles = this.matchBundles(locales);
        for (const bundle of bundles) {
            const [messageId, attributeName] = path.split(".", 2);
            const message = bundle.getMessage(messageId);
            if (!message) {
                this.warningHandler.handleWarning({
                    type: "translate.bundle.missing-message",
                    locales,
                    path,
                    matchedBundles: bundles,
                    context,
                    messageId,
                    bundle,
                });
                continue;
            }
            let pattern;
            if (attributeName) {
                pattern = message.attributes?.[attributeName];
                if (!pattern) {
                    this.warningHandler.handleWarning({
                        type: "translate.message.missing-attribute",
                        locales,
                        path,
                        matchedBundles: bundles,
                        context,
                        messageId,
                        attributeName,
                        bundle,
                    });
                    continue;
                }
            }
            else {
                pattern = message.value || "";
            }
            return bundle.formatPattern(pattern, context);
        }
        this.warningHandler.handleWarning({
            type: "translate.missing-translation",
            locales,
            path,
            matchedBundles: bundles,
            context,
        });
        // Returning translation placeholder in case when
        // message is not found
        return `{${path}}`;
    }
    /**
     * Returns translation function bound to the specified locale(s).
     */
    withLocale(localeOrLocales) {
        return this.translate.bind(this, localeOrLocales);
    }
    async handleSources(options) {
        if (options.filePath && options.source) {
            throw new Error(`You should specify either "filePath" or "source" ` +
                `option, not both`);
        }
        if (options.source || options.source === "") {
            return (Array.isArray(options.source)
                ? options.source.map(($source) => String($source))
                : [String(options.source)]);
        }
        else if (options.filePath) {
            const filePaths = Array.isArray(options.filePath)
                ? options.filePath
                : [options.filePath];
            const sources = [];
            for (const filePath of filePaths) {
                sources.push(await dntShim.Deno.readTextFile(filePath));
            }
            return sources;
        }
        else {
            throw new Error(`You should specify "filePath" or "source" option`);
        }
    }
    handleSourcesSync(options) {
        if (options.filePath && options.source) {
            throw new Error(`You should specify either "filePath" or "source" ` +
                `option, not both`);
        }
        if (options.source || options.source === "") {
            return (Array.isArray(options.source)
                ? options.source.map(($source) => String($source))
                : [String(options.source)]);
        }
        else if (options.filePath) {
            const filePaths = Array.isArray(options.filePath)
                ? options.filePath
                : [options.filePath];
            const sources = [];
            for (const filePath of filePaths) {
                sources.push(dntShim.Deno.readTextFileSync(filePath));
            }
            return sources;
        }
        else {
            throw new Error(`You should specify "filePath" or "source" option`);
        }
    }
    createBundle(options) {
        const { locales, sources, bundleOptions = {}, } = options;
        const bundle = new deps_js_1.FluentBundle(locales, bundleOptions);
        for (const source of sources) {
            const errors = bundle.addResource(new deps_js_1.FluentResource(source), { allowOverrides: true });
            if (errors?.length > 0) {
                for (const error of errors) {
                    console.error(error);
                }
                throw new Error(`Failed to parse Fluent resource, please check and ` +
                    `correct the errors printed above`);
            }
        }
        return bundle;
    }
    /**
     * Finds the most suitable bundles for the specified locales.
     */
    matchBundles(locales) {
        // Building a list of all the registered locales
        const availableLocales = new Set(Array.from(this.bundles)
            .reduce(($locales, bundle) => [
            ...$locales,
            ...bundle.locales,
        ], []));
        // Finding the best match
        const matchedLocales = (0, deps_js_1.negotiateLanguages)(locales, Array.from(availableLocales));
        // For each matched locale, finding the first bundle that includes it
        const matchedBundles = (matchedLocales
            .map((locale) => Array.from(this.bundles)
            .find((bundle) => bundle.locales.includes(locale)))
            .filter(Boolean));
        // Always adding the default bundle to the end of the list
        if (this.defaultBundle) {
            matchedBundles.push(this.defaultBundle);
        }
        return new Set(matchedBundles);
    }
}
exports.Fluent = Fluent;
